# Justification for Using Synchronous Add and Remove Methods in Generic Repository

## Decision Context

There is a need to determine whether the synchronous versions of Add and Remove methods will be used in the generic repository layer, despite Entity Framework Core providing asynchronous counterparts (AddAsync and RemoveAsync) for certain operations.

### Decision: Use Synchronous Add and Remove Methods

#### Justifications

Async Not Required for Simple State Changes:

The Add and Remove methods in EF Core do not involve I/O or database operations at the time of their execution.
Both methods only modify the DbContext's in-memory state, marking the entity as Added or Deleted. Actual database interaction happens during SaveChanges or SaveChangesAsync.
No Benefit in Using AddAsync/RemoveAsync:

AddAsync is primarily useful for detached/graph-like scenarios with DbContext features like lazy-loading proxies, and its async behavior is rarely utilized in typical Add scenarios.
Remove has no async counterpart because it always operates synchronously on the in-memory context state.
Alignment with Repository Granularity:

The repository typically batches operations (e.g., via SaveChangesAsync), where async behavior optimizes I/O.
Using synchronous state changes like Add/Remove aligns with the goal of decoupling repository methods from transaction handling (SaveChanges).
Simplified API Usage:

Using synchronous methods avoids confusion when there’s no tangible I/O benefit, thereby keeping the repository implementation simpler.

#### Risks & Countermeasures

Risk: Async workflows might not align with repository design.
Countermeasure: Always ensure async saved operations (e.g., SaveChangesAsync) are used at the end of the unit of work.

## Final Decision

Stick to synchronous Add and Remove methods for generic repository methods where they simply modify the EF Core context state. Use SaveChangesAsync for all database interactions to ensure async I/O benefits are realized where appropriate.

